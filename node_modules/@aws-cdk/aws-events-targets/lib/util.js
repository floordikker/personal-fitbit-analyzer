"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToDeadLetterQueueResourcePolicy = exports.addLambdaPermission = exports.singletonEventRole = void 0;
const iam = require("@aws-cdk/aws-iam");
const core_1 = require("@aws-cdk/core");
// keep this import separate from other imports to reduce chance for merge conflicts with v2-main
// eslint-disable-next-line no-duplicate-imports, import/order
const core_2 = require("@aws-cdk/core");
/**
 * Obtain the Role for the EventBridge event
 *
 * If a role already exists, it will be returned. This ensures that if multiple
 * events have the same target, they will share a role.
 */
function singletonEventRole(scope, policyStatements) {
    const id = 'EventsRole';
    const existing = scope.node.tryFindChild(id);
    if (existing) {
        return existing;
    }
    const role = new iam.Role(scope, id, {
        assumedBy: new iam.ServicePrincipal('events.amazonaws.com'),
    });
    policyStatements.forEach(role.addToPolicy.bind(role));
    return role;
}
exports.singletonEventRole = singletonEventRole;
/**
 * Allows a Lambda function to be called from a rule
 */
function addLambdaPermission(rule, handler) {
    let scope;
    let node = handler.permissionsNode;
    let permissionId = `AllowEventRule${core_1.Names.nodeUniqueId(rule.node)}`;
    if (rule instanceof core_2.Construct) {
        // Place the Permission resource in the same stack as Rule rather than the Function
        // This is to reduce circular dependency when the lambda handler and the rule are across stacks.
        scope = rule;
        node = rule.node;
        permissionId = `AllowEventRule${core_1.Names.nodeUniqueId(handler.node)}`;
    }
    if (!node.tryFindChild(permissionId)) {
        handler.addPermission(permissionId, {
            scope,
            action: 'lambda:InvokeFunction',
            principal: new iam.ServicePrincipal('events.amazonaws.com'),
            sourceArn: rule.ruleArn,
        });
    }
}
exports.addLambdaPermission = addLambdaPermission;
/**
 * Allow a rule to send events with failed invocation to an Amazon SQS queue.
 */
function addToDeadLetterQueueResourcePolicy(rule, queue) {
    if (!sameEnvDimension(rule.env.region, queue.env.region)) {
        throw new Error(`Cannot assign Dead Letter Queue in region ${queue.env.region} to the rule ${core_1.Names.nodeUniqueId(rule.node)} in region ${rule.env.region}. Both the queue and the rule must be in the same region.`);
    }
    // Skip Resource Policy creation if the Queue is not in the same account.
    // There is no way to add a target onto an imported rule, so we can assume we will run the following code only
    // in the account where the rule is created.
    if (sameEnvDimension(rule.env.account, queue.env.account)) {
        const policyStatementId = `AllowEventRule${core_1.Names.nodeUniqueId(rule.node)}`;
        queue.addToResourcePolicy(new iam.PolicyStatement({
            sid: policyStatementId,
            principals: [new iam.ServicePrincipal('events.amazonaws.com')],
            effect: iam.Effect.ALLOW,
            actions: ['sqs:SendMessage'],
            resources: [queue.queueArn],
            conditions: {
                ArnEquals: {
                    'aws:SourceArn': rule.ruleArn,
                },
            },
        }));
    }
    else {
        core_1.Annotations.of(rule).addWarning(`Cannot add a resource policy to your dead letter queue associated with rule ${rule.ruleName} because the queue is in a different account. You must add the resource policy manually to the dead letter queue in account ${queue.env.account}.`);
    }
}
exports.addToDeadLetterQueueResourcePolicy = addToDeadLetterQueueResourcePolicy;
/**
 * Whether two string probably contain the same environment dimension (region or account)
 *
 * Used to compare either accounts or regions, and also returns true if both
 * are unresolved (in which case both are expted to be "current region" or "current account").
 */
function sameEnvDimension(dim1, dim2) {
    return [core_1.TokenComparison.SAME, core_1.TokenComparison.BOTH_UNRESOLVED].includes(core_1.Token.compareStrings(dim1, dim2));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0Esd0NBQXdDO0FBR3hDLHdDQUFzRztBQUV0RyxpR0FBaUc7QUFDakcsOERBQThEO0FBQzlELHdDQUEwQztBQUUxQzs7Ozs7R0FLRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLEtBQWlCLEVBQUUsZ0JBQXVDO0lBQzNGLE1BQU0sRUFBRSxHQUFHLFlBQVksQ0FBQztJQUN4QixNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQWMsQ0FBQztJQUMxRCxJQUFJLFFBQVEsRUFBRTtRQUFFLE9BQU8sUUFBUSxDQUFDO0tBQUU7SUFFbEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQWtCLEVBQUUsRUFBRSxFQUFFO1FBQ2hELFNBQVMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQztLQUM1RCxDQUFDLENBQUM7SUFFSCxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUV0RCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFaRCxnREFZQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsbUJBQW1CLENBQUMsSUFBa0IsRUFBRSxPQUF5QjtJQUMvRSxJQUFJLEtBQTRCLENBQUM7SUFDakMsSUFBSSxJQUFJLEdBQWtCLE9BQU8sQ0FBQyxlQUFlLENBQUM7SUFDbEQsSUFBSSxZQUFZLEdBQUcsaUJBQWlCLFlBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDcEUsSUFBSSxJQUFJLFlBQVksZ0JBQVMsRUFBRTtRQUM3QixtRkFBbUY7UUFDbkYsZ0dBQWdHO1FBQ2hHLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDYixJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNqQixZQUFZLEdBQUcsaUJBQWlCLFlBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7S0FDcEU7SUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsRUFBRTtRQUNwQyxPQUFPLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRTtZQUNsQyxLQUFLO1lBQ0wsTUFBTSxFQUFFLHVCQUF1QjtZQUMvQixTQUFTLEVBQUUsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsc0JBQXNCLENBQUM7WUFDM0QsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPO1NBQ3hCLENBQUMsQ0FBQztLQUNKO0FBQ0gsQ0FBQztBQW5CRCxrREFtQkM7QUFFRDs7R0FFRztBQUNILFNBQWdCLGtDQUFrQyxDQUFDLElBQWtCLEVBQUUsS0FBaUI7SUFDdEYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDeEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLGdCQUFnQixZQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sMkRBQTJELENBQUMsQ0FBQztLQUNyTjtJQUVELHlFQUF5RTtJQUN6RSw4R0FBOEc7SUFDOUcsNENBQTRDO0lBQzVDLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUN6RCxNQUFNLGlCQUFpQixHQUFHLGlCQUFpQixZQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBRTNFLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxlQUFlLENBQUM7WUFDaEQsR0FBRyxFQUFFLGlCQUFpQjtZQUN0QixVQUFVLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQzlELE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUs7WUFDeEIsT0FBTyxFQUFFLENBQUMsaUJBQWlCLENBQUM7WUFDNUIsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztZQUMzQixVQUFVLEVBQUU7Z0JBQ1YsU0FBUyxFQUFFO29CQUNULGVBQWUsRUFBRSxJQUFJLENBQUMsT0FBTztpQkFDOUI7YUFDRjtTQUNGLENBQUMsQ0FBQyxDQUFDO0tBQ0w7U0FBTTtRQUNMLGtCQUFXLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQywrRUFBK0UsSUFBSSxDQUFDLFFBQVEsK0hBQStILEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztLQUNsUjtBQUNILENBQUM7QUExQkQsZ0ZBMEJDO0FBR0Q7Ozs7O0dBS0c7QUFDSCxTQUFTLGdCQUFnQixDQUFDLElBQVksRUFBRSxJQUFZO0lBQ2xELE9BQU8sQ0FBQyxzQkFBZSxDQUFDLElBQUksRUFBRSxzQkFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFLLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzVHLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnQGF3cy1jZGsvYXdzLWV2ZW50cyc7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSAnQGF3cy1jZGsvYXdzLWlhbSc7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSAnQGF3cy1jZGsvYXdzLWxhbWJkYSc7XG5pbXBvcnQgKiBhcyBzcXMgZnJvbSAnQGF3cy1jZGsvYXdzLXNxcyc7XG5pbXBvcnQgeyBBbm5vdGF0aW9ucywgQ29uc3RydWN0Tm9kZSwgSUNvbnN0cnVjdCwgTmFtZXMsIFRva2VuLCBUb2tlbkNvbXBhcmlzb24gfSBmcm9tICdAYXdzLWNkay9jb3JlJztcblxuLy8ga2VlcCB0aGlzIGltcG9ydCBzZXBhcmF0ZSBmcm9tIG90aGVyIGltcG9ydHMgdG8gcmVkdWNlIGNoYW5jZSBmb3IgbWVyZ2UgY29uZmxpY3RzIHdpdGggdjItbWFpblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGxpY2F0ZS1pbXBvcnRzLCBpbXBvcnQvb3JkZXJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuXG4vKipcbiAqIE9idGFpbiB0aGUgUm9sZSBmb3IgdGhlIEV2ZW50QnJpZGdlIGV2ZW50XG4gKlxuICogSWYgYSByb2xlIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIHJldHVybmVkLiBUaGlzIGVuc3VyZXMgdGhhdCBpZiBtdWx0aXBsZVxuICogZXZlbnRzIGhhdmUgdGhlIHNhbWUgdGFyZ2V0LCB0aGV5IHdpbGwgc2hhcmUgYSByb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xldG9uRXZlbnRSb2xlKHNjb3BlOiBJQ29uc3RydWN0LCBwb2xpY3lTdGF0ZW1lbnRzOiBpYW0uUG9saWN5U3RhdGVtZW50W10pOiBpYW0uSVJvbGUge1xuICBjb25zdCBpZCA9ICdFdmVudHNSb2xlJztcbiAgY29uc3QgZXhpc3RpbmcgPSBzY29wZS5ub2RlLnRyeUZpbmRDaGlsZChpZCkgYXMgaWFtLklSb2xlO1xuICBpZiAoZXhpc3RpbmcpIHsgcmV0dXJuIGV4aXN0aW5nOyB9XG5cbiAgY29uc3Qgcm9sZSA9IG5ldyBpYW0uUm9sZShzY29wZSBhcyBDb25zdHJ1Y3QsIGlkLCB7XG4gICAgYXNzdW1lZEJ5OiBuZXcgaWFtLlNlcnZpY2VQcmluY2lwYWwoJ2V2ZW50cy5hbWF6b25hd3MuY29tJyksXG4gIH0pO1xuXG4gIHBvbGljeVN0YXRlbWVudHMuZm9yRWFjaChyb2xlLmFkZFRvUG9saWN5LmJpbmQocm9sZSkpO1xuXG4gIHJldHVybiByb2xlO1xufVxuXG4vKipcbiAqIEFsbG93cyBhIExhbWJkYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZnJvbSBhIHJ1bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExhbWJkYVBlcm1pc3Npb24ocnVsZTogZXZlbnRzLklSdWxlLCBoYW5kbGVyOiBsYW1iZGEuSUZ1bmN0aW9uKTogdm9pZCB7XG4gIGxldCBzY29wZTogQ29uc3RydWN0IHwgdW5kZWZpbmVkO1xuICBsZXQgbm9kZTogQ29uc3RydWN0Tm9kZSA9IGhhbmRsZXIucGVybWlzc2lvbnNOb2RlO1xuICBsZXQgcGVybWlzc2lvbklkID0gYEFsbG93RXZlbnRSdWxlJHtOYW1lcy5ub2RlVW5pcXVlSWQocnVsZS5ub2RlKX1gO1xuICBpZiAocnVsZSBpbnN0YW5jZW9mIENvbnN0cnVjdCkge1xuICAgIC8vIFBsYWNlIHRoZSBQZXJtaXNzaW9uIHJlc291cmNlIGluIHRoZSBzYW1lIHN0YWNrIGFzIFJ1bGUgcmF0aGVyIHRoYW4gdGhlIEZ1bmN0aW9uXG4gICAgLy8gVGhpcyBpcyB0byByZWR1Y2UgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aGVuIHRoZSBsYW1iZGEgaGFuZGxlciBhbmQgdGhlIHJ1bGUgYXJlIGFjcm9zcyBzdGFja3MuXG4gICAgc2NvcGUgPSBydWxlO1xuICAgIG5vZGUgPSBydWxlLm5vZGU7XG4gICAgcGVybWlzc2lvbklkID0gYEFsbG93RXZlbnRSdWxlJHtOYW1lcy5ub2RlVW5pcXVlSWQoaGFuZGxlci5ub2RlKX1gO1xuICB9XG4gIGlmICghbm9kZS50cnlGaW5kQ2hpbGQocGVybWlzc2lvbklkKSkge1xuICAgIGhhbmRsZXIuYWRkUGVybWlzc2lvbihwZXJtaXNzaW9uSWQsIHtcbiAgICAgIHNjb3BlLFxuICAgICAgYWN0aW9uOiAnbGFtYmRhOkludm9rZUZ1bmN0aW9uJyxcbiAgICAgIHByaW5jaXBhbDogbmV3IGlhbS5TZXJ2aWNlUHJpbmNpcGFsKCdldmVudHMuYW1hem9uYXdzLmNvbScpLFxuICAgICAgc291cmNlQXJuOiBydWxlLnJ1bGVBcm4sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGxvdyBhIHJ1bGUgdG8gc2VuZCBldmVudHMgd2l0aCBmYWlsZWQgaW52b2NhdGlvbiB0byBhbiBBbWF6b24gU1FTIHF1ZXVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkVG9EZWFkTGV0dGVyUXVldWVSZXNvdXJjZVBvbGljeShydWxlOiBldmVudHMuSVJ1bGUsIHF1ZXVlOiBzcXMuSVF1ZXVlKSB7XG4gIGlmICghc2FtZUVudkRpbWVuc2lvbihydWxlLmVudi5yZWdpb24sIHF1ZXVlLmVudi5yZWdpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXNzaWduIERlYWQgTGV0dGVyIFF1ZXVlIGluIHJlZ2lvbiAke3F1ZXVlLmVudi5yZWdpb259IHRvIHRoZSBydWxlICR7TmFtZXMubm9kZVVuaXF1ZUlkKHJ1bGUubm9kZSl9IGluIHJlZ2lvbiAke3J1bGUuZW52LnJlZ2lvbn0uIEJvdGggdGhlIHF1ZXVlIGFuZCB0aGUgcnVsZSBtdXN0IGJlIGluIHRoZSBzYW1lIHJlZ2lvbi5gKTtcbiAgfVxuXG4gIC8vIFNraXAgUmVzb3VyY2UgUG9saWN5IGNyZWF0aW9uIGlmIHRoZSBRdWV1ZSBpcyBub3QgaW4gdGhlIHNhbWUgYWNjb3VudC5cbiAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFkZCBhIHRhcmdldCBvbnRvIGFuIGltcG9ydGVkIHJ1bGUsIHNvIHdlIGNhbiBhc3N1bWUgd2Ugd2lsbCBydW4gdGhlIGZvbGxvd2luZyBjb2RlIG9ubHlcbiAgLy8gaW4gdGhlIGFjY291bnQgd2hlcmUgdGhlIHJ1bGUgaXMgY3JlYXRlZC5cbiAgaWYgKHNhbWVFbnZEaW1lbnNpb24ocnVsZS5lbnYuYWNjb3VudCwgcXVldWUuZW52LmFjY291bnQpKSB7XG4gICAgY29uc3QgcG9saWN5U3RhdGVtZW50SWQgPSBgQWxsb3dFdmVudFJ1bGUke05hbWVzLm5vZGVVbmlxdWVJZChydWxlLm5vZGUpfWA7XG5cbiAgICBxdWV1ZS5hZGRUb1Jlc291cmNlUG9saWN5KG5ldyBpYW0uUG9saWN5U3RhdGVtZW50KHtcbiAgICAgIHNpZDogcG9saWN5U3RhdGVtZW50SWQsXG4gICAgICBwcmluY2lwYWxzOiBbbmV3IGlhbS5TZXJ2aWNlUHJpbmNpcGFsKCdldmVudHMuYW1hem9uYXdzLmNvbScpXSxcbiAgICAgIGVmZmVjdDogaWFtLkVmZmVjdC5BTExPVyxcbiAgICAgIGFjdGlvbnM6IFsnc3FzOlNlbmRNZXNzYWdlJ10sXG4gICAgICByZXNvdXJjZXM6IFtxdWV1ZS5xdWV1ZUFybl0sXG4gICAgICBjb25kaXRpb25zOiB7XG4gICAgICAgIEFybkVxdWFsczoge1xuICAgICAgICAgICdhd3M6U291cmNlQXJuJzogcnVsZS5ydWxlQXJuLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgQW5ub3RhdGlvbnMub2YocnVsZSkuYWRkV2FybmluZyhgQ2Fubm90IGFkZCBhIHJlc291cmNlIHBvbGljeSB0byB5b3VyIGRlYWQgbGV0dGVyIHF1ZXVlIGFzc29jaWF0ZWQgd2l0aCBydWxlICR7cnVsZS5ydWxlTmFtZX0gYmVjYXVzZSB0aGUgcXVldWUgaXMgaW4gYSBkaWZmZXJlbnQgYWNjb3VudC4gWW91IG11c3QgYWRkIHRoZSByZXNvdXJjZSBwb2xpY3kgbWFudWFsbHkgdG8gdGhlIGRlYWQgbGV0dGVyIHF1ZXVlIGluIGFjY291bnQgJHtxdWV1ZS5lbnYuYWNjb3VudH0uYCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFdoZXRoZXIgdHdvIHN0cmluZyBwcm9iYWJseSBjb250YWluIHRoZSBzYW1lIGVudmlyb25tZW50IGRpbWVuc2lvbiAocmVnaW9uIG9yIGFjY291bnQpXG4gKlxuICogVXNlZCB0byBjb21wYXJlIGVpdGhlciBhY2NvdW50cyBvciByZWdpb25zLCBhbmQgYWxzbyByZXR1cm5zIHRydWUgaWYgYm90aFxuICogYXJlIHVucmVzb2x2ZWQgKGluIHdoaWNoIGNhc2UgYm90aCBhcmUgZXhwdGVkIHRvIGJlIFwiY3VycmVudCByZWdpb25cIiBvciBcImN1cnJlbnQgYWNjb3VudFwiKS5cbiAqL1xuZnVuY3Rpb24gc2FtZUVudkRpbWVuc2lvbihkaW0xOiBzdHJpbmcsIGRpbTI6IHN0cmluZykge1xuICByZXR1cm4gW1Rva2VuQ29tcGFyaXNvbi5TQU1FLCBUb2tlbkNvbXBhcmlzb24uQk9USF9VTlJFU09MVkVEXS5pbmNsdWRlcyhUb2tlbi5jb21wYXJlU3RyaW5ncyhkaW0xLCBkaW0yKSk7XG59Il19